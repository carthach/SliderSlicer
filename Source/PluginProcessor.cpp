/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"



//==============================================================================
SlicerAudioProcessor::SlicerAudioProcessor()
{
    record = false;
    play = false;
    firstTimeRecord = true;
    firstTimePlay = true;
    
    glitchBuffer =  AudioSampleBuffer(2, 88200);
    
    glitchBuffer.applyGain(0.0f); //Zero data

    glitchCounter = 0;
    glitchMax = 0;
    
    index = 0;
    
    resetSliceArray(glitchIO::IN, 16);
    resetSliceArray(glitchIO::OUT, 16);
    
    inSliceSliderVal = outSliceSliderVal = 3;
}

void SlicerAudioProcessor::resetSliceArray(glitchIO type, int subDiv)
{
    if (type == glitchIO::IN) {
        inSlice.clear();
        for(int i=0; i<subDiv; i++)
            inSlice.add(false);
        inSubDiv = subDiv;
    } else {
        if (type == glitchIO::OUT) {
            outSlice.clear();
            for(int i=0; i<subDiv; i++)
                outSlice.add(false);
            outSubDiv = subDiv;
        }
    }
}

SlicerAudioProcessor::~SlicerAudioProcessor()
{
}

//==============================================================================
const String SlicerAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int SlicerAudioProcessor::getNumParameters()
{
    return 0;
}

float SlicerAudioProcessor::getParameter (int index)
{
    return 0.0f;
}

void SlicerAudioProcessor::setParameter (int index, float newValue)
{
}

const String SlicerAudioProcessor::getParameterName (int index)
{
    return String();
}

const String SlicerAudioProcessor::getParameterText (int index)
{
    return String();
}

const String SlicerAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String SlicerAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool SlicerAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool SlicerAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool SlicerAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool SlicerAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool SlicerAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double SlicerAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int SlicerAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int SlicerAudioProcessor::getCurrentProgram()
{
    return 0;
}

void SlicerAudioProcessor::setCurrentProgram (int index)
{
}

const String SlicerAudioProcessor::getProgramName (int index)
{
    return String();
}

void SlicerAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void SlicerAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void SlicerAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}


void SlicerAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // ask the host for the current time so we can display it...
    AudioPlayHead::CurrentPositionInfo newTime;
    
    double ppq = 0.0;
    
    if (getPlayHead() != nullptr && getPlayHead()->getCurrentPosition (newTime))
    {
        // Successfully got the current time from the host..
        lastPosInfo = newTime;
        
        ppq = newTime.ppqPosition;
    }
    else
    {
        // If the host fails to fill-in the current time, we'll just clear it to a default..
        lastPosInfo.resetToDefault();
    }
    
    double ppqWrap = fmodf(ppq, 4.0);
    double inRange = 4.0 / inSubDiv;
    
    
    for(int i=0; i<inSubDiv; i++) {
        float low = i * inRange;
        float high = i+1 * inRange;
        
        if (ppqWrap > low && ppqWrap < high)
            index = i;
    }
    
    if (inSlice[index]) {
        if(firstTimeRecord) {
            firstTimeRecord = false;
            glitchCounter = 0;
        }
        record = true; //Record and increment
    } else {
        firstTimeRecord = true;
        record = false;
    }
    
    double outRange = 4.0 / outSubDiv;
    
    for(int i=0; i<outSubDiv; i++) {
        float low = i * outRange;
        float high = i+1 * outRange;
        
        if (ppqWrap > low && ppqWrap < high)
            index = i;
    }
    
    if (outSlice[index]) {
        if(firstTimePlay) {
            firstTimePlay = false;
            glitchMax = glitchCounter;
            glitchCounter = 0;
        }
        play = true;
    } else {
        firstTimePlay = true;
        play = false;
    }
    
    if (newTime.isPlaying) {
        float* bufferL = buffer.getWritePointer (0);
        float* glitchL = glitchBuffer.getWritePointer(0, glitchCounter);
        
        float* bufferR;
        float* glitchR;
        
        if(buffer.getNumChannels() == 2) {
            bufferR = buffer.getWritePointer(1);
            glitchR = glitchBuffer.getWritePointer(1, glitchCounter);
        }
        
        for (int i=0; i<buffer.getNumSamples(); i++) {
            
            if(record) {
                *glitchL++ = *bufferL;
                if(buffer.getNumChannels() == 2)
                    *glitchR++ = *bufferR;
            }
            else if (play && glitchMax > 64) {
                *bufferL = *glitchL++;
                if(buffer.getNumChannels() == 2)
                    *bufferR = *glitchR++;
            }
            
            bufferL++;
            bufferR++;
            
            if(play && glitchMax > 0 && glitchCounter >= glitchMax) {
                glitchCounter = 0;
            } else {
                if(play || record)
                    glitchCounter++;
            }
        }
    }
    
}

//==============================================================================
bool SlicerAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* SlicerAudioProcessor::createEditor()
{
    return new SlicerAudioProcessorEditor (*this);
}

//==============================================================================
void SlicerAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void SlicerAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new SlicerAudioProcessor();
}
