/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <cmath>

//==============================================================================
SlicerAudioProcessorEditor::SlicerAudioProcessorEditor (SlicerAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p),
    inSliceSubDivLabel(String::empty), outSliceSubDivLabel(String::empty),
    inSliceSubDivSlider(Slider::Rotary, Slider::NoTextBox), outSliceSubDivSlider(Slider::Rotary, Slider::NoTextBox)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (615, 300);
    startTimer(1000.0/60.0);

    Colour textColour = Colour(12, 177, 242);
    
    Colour thumbColour = Colour((uint8)34, (uint8)204, (uint8)242,  (float)175);
    
    myLookAndFeel.setColour(Label::textColourId, textColour);
    myLookAndFeel.setColour(Slider::textBoxTextColourId, textColour);
    myLookAndFeel.setColour(ToggleButton::textColourId, textColour);
    myLookAndFeel.setColour(Slider::rotarySliderFillColourId, textColour);
    myLookAndFeel.setColour(Slider::rotarySliderOutlineColourId, textColour);
    
    myLookAndFeel.setColour(Slider::thumbColourId, thumbColour);
    
    LookAndFeel::setDefaultLookAndFeel(&myLookAndFeel);
    
    // add a label that will display the current timecode and status..
    addAndMakeVisible (infoLabel);
    infoLabel.setBounds (15, 10, 400, 25);
    infoLabel.setText("SliderSlicer", NotificationType::dontSendNotification);
    infoLabel.setFont(Font("Verdana", 25.0, 2));
    
    // add a label that will display the current timecode and status..
    addAndMakeVisible (versionLabel);
    versionLabel.setBounds (140, 15, 50, 25);
    versionLabel.setText("v0.1", NotificationType::dontSendNotification);
    versionLabel.setFont(Font("Verdana", 10.0, 0));
    
    // add a label that will display the current timecode and status..
    addAndMakeVisible (inLabel);
    inLabel.setJustificationType(Justification::centred);
    inLabel.setBounds (5, 50, 50, 25);
    inLabel.setText("In", NotificationType::dontSendNotification);
    inLabel.setFont(Font("Verdana", 22.0, 0));
    
    addAndMakeVisible (inSliceSubDivSlider);
    inSliceSubDivSlider.addListener (this);
    inSliceSubDivSlider.setRange (2.0, 5.0, 1.0);
    inSliceSubDivSlider.setValue(2.0);
    inSliceSubDivSlider.setBounds (inLabel.getX()+6, inLabel.getY()+45, 40, 40);
    
    addAndMakeVisible(inSliceSubDivLabel);
    inSliceSubDivLabel.setJustificationType(Justification::centred);
    inSliceSubDivLabel.setBounds(inSliceSubDivSlider.getX()-5, inSliceSubDivSlider.getY()+22, 50, 50);
    
    // add a label that will display the current timecode and status..
    addAndMakeVisible (outLabel);
    outLabel.setJustificationType(Justification::centred);
    outLabel.setBounds (5, 175, 50, 25);
    outLabel.setText("Out", NotificationType::dontSendNotification);
    outLabel.setFont(Font("Verdana", 22.0, 0));
    
    addAndMakeVisible (outSliceSubDivSlider);
    outSliceSubDivSlider.addListener (this);
    outSliceSubDivSlider.setRange (2.0, 5.0, 1.0);
    outSliceSubDivSlider.setBounds (outLabel.getX()+6, outLabel.getY()+45, 40, 40);
     
    addAndMakeVisible(outSliceSubDivLabel);
    outSliceSubDivLabel.setJustificationType(Justification::centred);
    outSliceSubDivLabel.setBounds(outSliceSubDivSlider.getX()-5, outSliceSubDivSlider.getY()+22, 50, 50);
    
    //Buttons
    addAndMakeVisible(randomButton);
    randomButton.setBounds(500, inLabel.getY(), 100, 25);
    randomButton.addListener(this);
    randomButton.setButtonText("Randomise");
    
    //Buttons
    addAndMakeVisible(clearButton);
    clearButton.setBounds(500, inLabel.getY()+30, 100, 25);
    clearButton.addListener(this);
    clearButton.setButtonText("Clear");
    
    addAndMakeVisible(binaryToggleButton);
    binaryToggleButton.setBounds(500, inLabel.getY()+55, 100, 30);
    binaryToggleButton.addListener(this);
    binaryToggleButton.setButtonText("Binary");
    
    
    //Calling this sets up the sliders automatically
    inSliceSubDivSlider.setValue(processor.inSliceSliderVal, NotificationType::sendNotificationSync);
    outSliceSubDivSlider.setValue(processor.outSliceSliderVal, NotificationType::sendNotificationSync);
}

SlicerAudioProcessorEditor::~SlicerAudioProcessorEditor()
{
}

void SlicerAudioProcessorEditor::buttonClicked(Button * button)
{
    if(button == &randomButton)
        randomiseValues();
    if(button == &binaryToggleButton) {
        setRanges(binaryToggleButton.getToggleState());
        clearSliders();        
    }
    if(button == &clearButton) {
        clearSliders();
    }
}

void SlicerAudioProcessorEditor::clearSliders()
{
    for(int i=0 ;i<inSliceSliders.size();i++)
        inSliceSliders[i]->setValue(0.0f);
    for(int i=0 ;i<outSliceSliders.size();i++)
        outSliceSliders[i]->setValue(0.0f);
}

void SlicerAudioProcessorEditor::setRanges(bool binary)
{
    if(binary) {
        for (int i=0; i < inSliceSliders.size(); i++) {
            inSliceSliders[i]->setRange(0.0, 1.0,1.0);
        }
        for (int i=0; i < outSliceSliders.size(); i++) {
            outSliceSliders[i]->setRange(0.0, 1.0,1.0);
        }
    }
    else {
        for (int i=0; i < inSliceSliders.size(); i++) {
            inSliceSliders[i]->setRange(0.0, 10.0);
        }
        for (int i=0; i < outSliceSliders.size(); i++) {
            outSliceSliders[i]->setRange(0.0, 10.0);
        }
    }
}

void SlicerAudioProcessorEditor::randomiseValues()
{
    for(int i=0; i< inSliceSliders.size(); i++) {
        if (binaryToggleButton.getToggleState() == true) {
            if(outSliceSliders[i]->getValue() < 0.5)
                inSliceSliders[i]->setValue((float)rand.nextInt(2));
        }
        else
            inSliceSliders[i]->setValue(rand.nextFloat()*10.0);
    }
    for(int i=0; i< outSliceSliders.size(); i++) {
        if (binaryToggleButton.getToggleState() == true) {
            if(inSliceSliders[i]->getValue() < 0.5)
                outSliceSliders[i]->setValue((float)rand.nextInt(2));
        }
        else
            outSliceSliders[i]->setValue(rand.nextFloat()*10.0);
    }
}


OwnedArray<Slider> SlicerAudioProcessorEditor::setupSliders(int subDiv, int x, int y, bool overlay)
{
    OwnedArray<Slider> sliders;
    
    float xSize = 416.0/(float)subDiv;
    float xOffset = x;
    
    int modval = subDiv >> 2;
    
    for(int i=0; i< subDiv; i++) {
        sliders.add(new Slider(Slider::LinearBarVertical, Slider::NoTextBox));
        sliders[i]->setBounds(xOffset, y, xSize, 100);
        
        if (overlay)
            sliders[i]->setInterceptsMouseClicks(false, false);
        else {
            if(i % modval == 0)
                sliders[i]->setColour(Slider::backgroundColourId, Colours::darkgrey);
            else
                sliders[i]->setColour(Slider::backgroundColourId, Colours::lightgrey);
        }
        
        xOffset += xSize;
        addAndMakeVisible(sliders[i]);
    }
    
    return sliders;
}


void SlicerAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
    if (slider == &inSliceSubDivSlider) {
        int sliderValue = (int)slider->getValue();
        inSliceSubDiv = 1 << sliderValue;
        processor.inSliceSliderVal = sliderValue;
        
        String divText;
        divText << "1/" << inSliceSubDiv; //String creation
        inSliceSubDivLabel.setText(divText, dontSendNotification);
        
        inSliceSliders.clearQuick(true);
        inSliceOverlaySliders.clearQuick(true);
        inSliceSliders = setupSliders(inSliceSubDiv, inLabel.getX()+60, inLabel.getY(), false);
        inSliceOverlaySliders = setupSliders(inSliceSubDiv, inLabel.getX()+60, inLabel.getY(), true);
        processor.resetSliceArray(SlicerAudioProcessor::glitchIO::IN, inSliceSubDiv);
    }
    if (slider == &outSliceSubDivSlider) {
        int sliderValue = (int)slider->getValue();
        outSliceSubDiv = 1 << sliderValue;
        processor.outSliceSliderVal = sliderValue;
        
        String divText;
        divText << "1/" << outSliceSubDiv; //String creation
        outSliceSubDivLabel.setText(divText, dontSendNotification);

        outSliceSliders.clearQuick(true);
        outSliceOverlaySliders.clearQuick(true);
        outSliceSliders = setupSliders(outSliceSubDiv, outLabel.getX()+60, outLabel.getY(),false);
        outSliceOverlaySliders = setupSliders(outSliceSubDiv, outLabel.getX()+60, outLabel.getY(), true);
        processor.resetSliceArray(SlicerAudioProcessor::glitchIO::OUT, outSliceSubDiv);
    }
    
}

//==============================================================================
void SlicerAudioProcessorEditor::paint (Graphics& g)
{
    Colour backgroundColour = Colour(1, 21,38);
    g.fillAll (backgroundColour);

    
    AudioPlayHead::CurrentPositionInfo newPos (processor.lastPosInfo);
    
//    if (lastDisplayedPosition != newPos)
//        displayPositionInfo (newPos);
    
    updateStepSequence(newPos.ppqPosition);
}

void SlicerAudioProcessorEditor::updateStepSequence(double ppq)
{
    double ppqWrap = fmodf(ppq, 4.0);
    double range = 4.0 / inSliceSubDiv;
    
    for(int i=0; i<inSliceSubDiv; i++) {
        float low = i * range;
        float high = i+1 * range;
        
        if (ppqWrap > low && ppqWrap < high) {
            Colour c = Colours::red;
            c = c.withAlpha(0.5f);
            inSliceOverlaySliders[i]->setColour(Slider::backgroundColourId, c);
            
            for(int j=0; j<i; j++)
                inSliceOverlaySliders[j]->removeColour(Slider::backgroundColourId);
            
            for(int j=i+1; j<inSliceOverlaySliders.size(); j++)
                inSliceOverlaySliders[j]->removeColour(Slider::backgroundColourId);
        }
    }
    
    range = 4.0 / outSliceSubDiv;
    
    for(int i=0; i<outSliceSubDiv; i++) {
        float low = i * range;
        float high = i+1 * range;
        
        if (ppqWrap > low && ppqWrap < high) {
            Colour c = Colours::green;
            c = c.withAlpha(0.5f);
            outSliceOverlaySliders[i]->setColour(Slider::backgroundColourId, c);
            
            for(int j=0; j<i; j++)
                outSliceOverlaySliders[j]->removeColour(Slider::backgroundColourId);
            
            for(int j=i+1; j<outSliceOverlaySliders.size(); j++)
                outSliceOverlaySliders[j]->removeColour(Slider::backgroundColourId);
        }
    }
}

void SlicerAudioProcessorEditor::setGlitchPoints()
{
    for (int i=0; i<inSliceSliders.size(); i++) {
        if(binaryToggleButton.getToggleState()) {
            if(inSliceSliders[i]->getValue() >= 0.5f)
                processor.inSlice.set(i, true);
            else
                processor.inSlice.set(i, false);
        }
            
        else {
            float prob = rand.nextFloat() * 10.0f;
            if (prob <= inSliceSliders[i]->getValue())
                processor.inSlice.set(i, true);
            else
                processor.inSlice.set(i, false);
        }
    }
    for (int i=0; i<outSliceSliders.size(); i++) {
        if(binaryToggleButton.getToggleState()) {
            if(outSliceSliders[i]->getValue() >= 0.5f)
                processor.outSlice.set(i, true);
            else
                processor.outSlice.set(i, false);
        }
        
        else {
            float prob = rand.nextFloat() * 10.0f;
            if (prob <= outSliceSliders[i]->getValue())
                processor.outSlice.set(i, true);
            else
                processor.outSlice.set(i, false);
        }
    }
}

void SlicerAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
}

void SlicerAudioProcessorEditor::timerCallback()
{
    setGlitchPoints();
    
    repaint();
}

//==============================================================================
// quick-and-dirty function to format a timecode string
static String timeToTimecodeString (const double seconds)
{
    const double absSecs = std::abs (seconds);
    
    const int hours =  (int) (absSecs / (60.0 * 60.0));
    const int mins  = ((int) (absSecs / 60.0)) % 60;
    const int secs  = ((int) absSecs) % 60;
    
    String s (seconds < 0 ? "-" : "");
    
    s << String (hours).paddedLeft ('0', 2) << ":"
    << String (mins) .paddedLeft ('0', 2) << ":"
    << String (secs) .paddedLeft ('0', 2) << ":"
    << String (roundToInt (absSecs * 1000) % 1000).paddedLeft ('0', 3);
    
    return s;
}

// quick-and-dirty function to format a bars/beats string
String SlicerAudioProcessorEditor::ppqToBarsBeatsString (double ppq, double /*lastBarPPQ*/, int numerator, int denominator)
{
    if (numerator == 0 || denominator == 0)
        return "1|1|0";
    
    const int ppqPerBar = (numerator * 4 / denominator);
    const double beats  = (fmod (ppq, ppqPerBar) / ppqPerBar) * numerator;
        
    int bar = 0.0f;
    if(ppqPerBar != 0)
        bar    = ((int) ppq) / ppqPerBar + 1.0;
    const int beat   = ((int) beats) + 1;
    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));
    
    String s;
    s << bar << '|' << beat << '|' << ticks;
    return s;
}

// Updates the text in our position label.
void SlicerAudioProcessorEditor::displayPositionInfo (const AudioPlayHead::CurrentPositionInfo& pos)
{
    lastDisplayedPosition = pos;
    String displayText;
    displayText.preallocateBytes (128);
    
    displayText << String (pos.bpm, 2) << " bpm, "
    << pos.timeSigNumerator << '/' << pos.timeSigDenominator
    << "  -  " << timeToTimecodeString (pos.timeInSeconds)
    << "  -  " << ppqToBarsBeatsString (pos.ppqPosition, pos.ppqPositionOfLastBarStart,
                                        pos.timeSigNumerator, pos.timeSigDenominator);
    

    if (pos.isRecording)
        displayText << "  (recording)";
    else if (pos.isPlaying)
        displayText << "  (playing)";
    
    infoLabel.setText ("[" + SystemStats::getJUCEVersion() + "]   " + displayText, dontSendNotification);
}